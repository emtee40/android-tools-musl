diff --git a/libcrypto_utils/android_pubkey.c b/libcrypto_utils/android_pubkey.c
index 3052e52bf..bad3c73b0 100644
--- a/libcrypto_utils/android_pubkey.c
+++ b/libcrypto_utils/android_pubkey.c
@@ -65,6 +65,8 @@ bool android_pubkey_decode(const uint8_t* key_buffer, size_t size, RSA** key) {
   const RSAPublicKey* key_struct = (RSAPublicKey*)key_buffer;
   bool ret = false;
   uint8_t modulus_buffer[ANDROID_PUBKEY_MODULUS_SIZE];
+  BIGNUM* e;
+  BIGNUM* n;
   RSA* new_key = RSA_new();
   if (!new_key) {
     goto cleanup;
@@ -81,14 +83,18 @@ bool android_pubkey_decode(const uint8_t* key_buffer, size_t size, RSA** key) {
   // Convert the modulus to big-endian byte order as expected by BN_bin2bn.
   memcpy(modulus_buffer, key_struct->modulus, sizeof(modulus_buffer));
   reverse_bytes(modulus_buffer, sizeof(modulus_buffer));
-  new_key->n = BN_bin2bn(modulus_buffer, sizeof(modulus_buffer), NULL);
-  if (!new_key->n) {
+  n = BN_bin2bn(modulus_buffer, sizeof(modulus_buffer), NULL);
+  if (!n) {
     goto cleanup;
   }
 
   // Read the exponent.
-  new_key->e = BN_new();
-  if (!new_key->e || !BN_set_word(new_key->e, key_struct->exponent)) {
+  e = BN_new();
+  if (!e || !BN_set_word(e, key_struct->exponent)) {
+    goto cleanup;
+  }
+
+  if (!RSA_set0_key(new_key, e, n, NULL)) {
     goto cleanup;
   }
 
@@ -126,37 +132,41 @@ bool android_pubkey_encode(const RSA* key, uint8_t* key_buffer, size_t size) {
   BIGNUM* r32 = BN_new();
   BIGNUM* n0inv = BN_new();
   BIGNUM* rr = BN_new();
+  const BIGNUM* e;
+  const BIGNUM* n;
 
   if (sizeof(RSAPublicKey) > size ||
       RSA_size(key) != ANDROID_PUBKEY_MODULUS_SIZE) {
     goto cleanup;
   }
 
+  RSA_get0_key(key, &e, &n, NULL);
+
   // Store the modulus size.
   key_struct->modulus_size_words = ANDROID_PUBKEY_MODULUS_SIZE_WORDS;
 
   // Compute and store n0inv = -1 / N[0] mod 2^32.
   if (!ctx || !r32 || !n0inv || !BN_set_bit(r32, 32) ||
-      !BN_mod(n0inv, key->n, r32, ctx) ||
+      !BN_mod(n0inv, n, r32, ctx) ||
       !BN_mod_inverse(n0inv, n0inv, r32, ctx) || !BN_sub(n0inv, r32, n0inv)) {
     goto cleanup;
   }
   key_struct->n0inv = (uint32_t)BN_get_word(n0inv);
 
   // Store the modulus.
-  if (!android_pubkey_encode_bignum(key->n, key_struct->modulus)) {
+  if (!android_pubkey_encode_bignum(n, key_struct->modulus)) {
     goto cleanup;
   }
 
   // Compute and store rr = (2^(rsa_size)) ^ 2 mod N.
   if (!ctx || !rr || !BN_set_bit(rr, ANDROID_PUBKEY_MODULUS_SIZE * 8) ||
-      !BN_mod_sqr(rr, rr, key->n, ctx) ||
+      !BN_mod_sqr(rr, rr, n, ctx) ||
       !android_pubkey_encode_bignum(rr, key_struct->rr)) {
     goto cleanup;
   }
 
   // Store the exponent.
-  key_struct->exponent = (uint32_t)BN_get_word(key->e);
+  key_struct->exponent = (uint32_t)BN_get_word(e);
 
   ret = true;
 
